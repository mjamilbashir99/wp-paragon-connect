{"version":3,"sources":["../../src/evaluator/index.js"],"names":["TypedValue","constructor","type","value","types","isInteger","BigNumber","isBigNumber","from","ethers","utils","isAddress","Error","getAddress","toString","Evaluator","ast","bindings","availableHelpers","provider","to","data","providers","WebSocketProvider","DEFAULT_ETH_NODE","helpers","HelperManager","evaluateNodes","nodes","Promise","all","map","evaluateNode","bind","node","Math","ceil","body","join","length","panic","left","right","operator","add","sub","mul","pow","div","mod","leftValue","rightValue","bothTypesAddress","bothTypesBytes","bytes","isType","gt","gte","lt","lte","eq","predicate","leftFalsey","isZero","startsWith","test","target","inputs","outputs","selectedReturnValueIndex","findIndex","output","selected","callee","returnType","abi","name","stateMutability","ethersInterface","Interface","txData","encodeFunctionData","input","call","decodeData","decodeFunctionResult","helperName","exists","result","execute","evaluator","property","hasOwnProperty","binding","evaluate","then","evaluatedNodes","msg","options"],"mappings":"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","sourcesContent":["/**\n * @module radspec/evaluator\n */\n\nimport { ethers, BigNumber } from 'ethers'\n\nimport types from '../types'\nimport HelperManager from '../helpers/HelperManager'\nimport { DEFAULT_ETH_NODE } from '../defaults'\n\n/**\n * A value coupled with a type\n *\n * @class TypedValue\n * @param {string} type The type of the value\n * @param {*} value The value\n * @property {string} type\n * @property {*} value\n */\nclass TypedValue {\n  constructor (type, value) {\n    this.type = type\n    this.value = value\n\n    if (types.isInteger(this.type) && !BigNumber.isBigNumber(this.value)) {\n      this.value = BigNumber.from(this.value)\n    }\n\n    if (this.type === 'address') {\n      if (!ethers.utils.isAddress(this.value)) {\n        throw new Error(`Invalid address \"${this.value}\"`)\n      }\n      this.value = ethers.utils.getAddress(this.value)\n    }\n  }\n\n  /**\n   * Get the string representation of the wrapped value\n   *\n   * @return {string}\n   */\n  toString () {\n    return this.value.toString()\n  }\n}\n\n/**\n * Walks an AST and evaluates each node.\n *\n * @class Evaluator\n * @param {radspec/parser/AST} ast The AST to evaluate\n * @param {radspec/Bindings} bindings An object of bindings and their values\n * @param {?Object} options An options object\n * @param {?Object} options.availablehelpers Available helpers\n * @param {?ethers.providers.Provider} options.provider EIP 1193 provider\n * @param {?string} options.to The destination address for this expression's transaction\n * @property {radspec/parser/AST} ast\n * @property {radspec/Bindings} bindings\n */\nexport class Evaluator {\n  constructor (\n    ast,\n    bindings,\n    { availableHelpers = {}, provider, from, to, value = '0', data } = {}\n  ) {\n    this.ast = ast\n    this.bindings = bindings\n    this.provider =\n      provider || new ethers.providers.WebSocketProvider(DEFAULT_ETH_NODE)\n    this.from = from && new TypedValue('address', from)\n    this.to = to && new TypedValue('address', to)\n    this.value = new TypedValue('uint', BigNumber.from(value))\n    this.data = data && new TypedValue('bytes', data)\n    this.helpers = new HelperManager(availableHelpers)\n  }\n\n  /**\n   * Evaluate an array of AST nodes.\n   *\n   * @param  {Array<radspec/parser/Node>} nodes\n   * @return {Promise<Array<string>>}\n   */\n  async evaluateNodes (nodes) {\n    return Promise.all(nodes.map(this.evaluateNode.bind(this)))\n  }\n\n  /**\n   * Evaluate a single node.\n   *\n   * @param  {radspec/parser/Node} node\n   * @return {Promise<string>}\n   */\n  async evaluateNode (node) {\n    if (node.type === 'ExpressionStatement') {\n      return (await this.evaluateNodes(node.body)).join(' ')\n    }\n\n    if (node.type === 'GroupedExpression') {\n      return this.evaluateNode(node.body)\n    }\n\n    if (node.type === 'MonologueStatement') {\n      return new TypedValue('string', node.value)\n    }\n\n    if (node.type === 'StringLiteral') {\n      return new TypedValue('string', node.value || '')\n    }\n\n    if (node.type === 'NumberLiteral') {\n      return new TypedValue('int256', node.value)\n    }\n\n    if (node.type === 'BytesLiteral') {\n      const length = Math.ceil((node.value.length - 2) / 2)\n      if (length > 32) {\n        this.panic('Byte literal represents more than 32 bytes')\n      }\n\n      return new TypedValue(`bytes${length}`, node.value)\n    }\n\n    if (node.type === 'BoolLiteral') {\n      return new TypedValue('bool', node.value === 'true')\n    }\n\n    if (node.type === 'BinaryExpression') {\n      const left = await this.evaluateNode(node.left)\n      const right = await this.evaluateNode(node.right)\n\n      // String concatenation\n      if (\n        (left.type === 'string' || right.type === 'string') &&\n        node.operator === 'PLUS'\n      ) {\n        return new TypedValue(\n          'string',\n          left.value.toString() + right.value.toString()\n        )\n      }\n\n      // TODO Additionally check that the type is signed if subtracting\n      if (!types.isInteger(left.type) || !types.isInteger(right.type)) {\n        this.panic(\n          `Cannot evaluate binary expression \"${node.operator}\" for non-integer types \"${left.type}\" and \"${right.type}\"`\n        )\n      }\n\n      switch (node.operator) {\n        case 'PLUS':\n          return new TypedValue('int256', left.value.add(right.value))\n        case 'MINUS':\n          return new TypedValue('int256', left.value.sub(right.value))\n        case 'STAR':\n          return new TypedValue('int256', left.value.mul(right.value))\n        case 'POWER':\n          return new TypedValue('int256', left.value.pow(right.value))\n        case 'SLASH':\n          return new TypedValue('int256', left.value.div(right.value))\n        case 'MODULO':\n          return new TypedValue('int256', left.value.mod(right.value))\n        default:\n          this.panic(`Undefined binary operator \"${node.operator}\"`)\n      }\n    }\n\n    if (node.type === 'ComparisonExpression') {\n      const left = await this.evaluateNode(node.left)\n      const right = await this.evaluateNode(node.right)\n\n      let leftValue = left.value\n      let rightValue = right.value\n\n      const bothTypesAddress = (left, right) =>\n        // isAddress is true if type is address or bytes with size less than 20\n        types.isAddress(left.type) && types.isAddress(right.type)\n\n      const bothTypesBytes = (left, right) =>\n        types.types.bytes.isType(left.type) &&\n        types.types.bytes.isType(right.type)\n\n      // Conversion to BigNumber for comparison will happen if:\n      // - Both types are addresses or bytes of any size (can be different sizes)\n      // - If one of the types is an address and the other bytes with size less than 20\n      if (bothTypesAddress(left, right) || bothTypesBytes(left, right)) {\n        leftValue = BigNumber.from(leftValue)\n        rightValue = BigNumber.from(rightValue)\n      } else if (!types.isInteger(left.type) || !types.isInteger(right.type)) {\n        this.panic(\n          `Cannot evaluate binary expression \"${node.operator}\" for non-integer or fixed-size bytes types \"${left.type}\" and \"${right.type}\"`\n        )\n      }\n\n      switch (node.operator) {\n        case 'GREATER':\n          return new TypedValue('bool', leftValue.gt(rightValue))\n        case 'GREATER_EQUAL':\n          return new TypedValue('bool', leftValue.gte(rightValue))\n        case 'LESS':\n          return new TypedValue('bool', leftValue.lt(rightValue))\n        case 'LESS_EQUAL':\n          return new TypedValue('bool', leftValue.lte(rightValue))\n        case 'EQUAL_EQUAL':\n          return new TypedValue('bool', leftValue.eq(rightValue))\n        case 'BANG_EQUAL':\n          return new TypedValue('bool', !leftValue.eq(rightValue))\n      }\n    }\n\n    if (node.type === 'TernaryExpression') {\n      if ((await this.evaluateNode(node.predicate)).value) {\n        return this.evaluateNode(node.left)\n      }\n\n      return this.evaluateNode(node.right)\n    }\n\n    if (node.type === 'DefaultExpression') {\n      const left = await this.evaluateNode(node.left)\n      let leftFalsey\n\n      if (types.isInteger(left.type)) {\n        leftFalsey = left.value.isZero()\n      } else if (left.type === 'address' || left.type.startsWith('bytes')) {\n        leftFalsey = /^0x[0]*$/.test(left.value)\n      } else {\n        leftFalsey = !left.value\n      }\n\n      return leftFalsey ? this.evaluateNode(node.right) : left\n    }\n\n    if (node.type === 'CallExpression') {\n      let target\n\n      // Inject self\n      if (node.target.type === 'Identifier' && node.target.value === 'self') {\n        target = this.to\n      } else {\n        target = await this.evaluateNode(node.target)\n      }\n\n      if (target.type !== 'bytes20' && target.type !== 'address') {\n        this.panic('Target of call expression was not an address')\n      } else if (!ethers.utils.isAddress(target.value)) {\n        this.panic(`Invalid address \"${this.value}\"`)\n      }\n\n      const inputs = await this.evaluateNodes(node.inputs)\n      const outputs = node.outputs\n      const selectedReturnValueIndex = outputs.findIndex(\n        (output) => output.selected\n      )\n      if (selectedReturnValueIndex === -1) {\n        this.panic(\n          `No selected return value for function call \"${node.callee}\"`\n        )\n      }\n      const returnType = outputs[selectedReturnValueIndex].type\n\n      const abi = [\n        {\n          name: node.callee,\n          type: 'function',\n          inputs: inputs.map(({ type }) => ({\n            type\n          })),\n          outputs: outputs.map(({ type }) => ({\n            type\n          })),\n          stateMutability: 'view'\n        }\n      ]\n      const ethersInterface = new ethers.utils.Interface(abi)\n\n      const txData = ethersInterface.encodeFunctionData(\n        node.callee,\n        inputs.map((input) => input.value.toString())\n      )\n\n      const data = await this.provider.call({\n        to: target.value,\n        data: txData\n      })\n\n      const decodeData = ethersInterface.decodeFunctionResult(node.callee, data)\n\n      return new TypedValue(returnType, decodeData[selectedReturnValueIndex])\n    }\n\n    if (node.type === 'HelperFunction') {\n      const helperName = node.name\n\n      if (!this.helpers.exists(helperName)) {\n        this.panic(`${helperName} helper function is not defined`)\n      }\n\n      const inputs = await this.evaluateNodes(node.inputs)\n      const result = await this.helpers.execute(helperName, inputs, {\n        provider: this.provider,\n        evaluator: this\n      })\n\n      return new TypedValue(result.type, result.value)\n    }\n\n    if (\n      node.type === 'PropertyAccessExpression' &&\n      node.target.value === 'msg'\n    ) {\n      if (node.property === 'value') {\n        return this.value\n      }\n\n      if (node.property === 'sender') {\n        return this.from\n      }\n\n      if (node.property === 'data') {\n        return this.data\n      }\n\n      this.panic(\n        `Expecting value, sender or data property for msg identifier but got: ${node.property}`\n      )\n    }\n\n    if (node.type === 'Identifier') {\n      if (node.value === 'self') {\n        return this.to\n      }\n\n      if (!this.bindings.hasOwnProperty(node.value)) {\n        this.panic(`Undefined binding \"${node.value}\"`)\n      }\n\n      const binding = this.bindings[node.value]\n      return new TypedValue(binding.type, binding.value)\n    }\n  }\n\n  /**\n   * Evaluate the entire AST.\n   *\n   * @return {string}\n   */\n  async evaluate () {\n    return this.evaluateNodes(this.ast.body).then((evaluatedNodes) =>\n      evaluatedNodes.join('')\n    )\n  }\n\n  /**\n   * Report an error and abort evaluation.\n   *\n   * @param  {string} msg\n   */\n  panic (msg) {\n    throw new Error(`Error: ${msg}`)\n  }\n}\n\n/**\n * Evaluates an AST\n *\n * @memberof radspec/evaluator\n * @param {radspec/parser/AST} ast The AST to evaluate\n * @param {radspec/Bindings} bindings An object of bindings and their values\n * @param {?Object} options An options object\n * @param {?Object} options.availablehelpers Available helpers\n * @param {?ethers.providers.Provider} options.provider EIP 1193 provider\n * @param {?string} options.to The destination address for this expression's transaction\n * @return {string}\n */\nexport function evaluate (ast, bindings, options) {\n  return new Evaluator(ast, bindings, options).evaluate()\n}\n"],"file":"index.js"}