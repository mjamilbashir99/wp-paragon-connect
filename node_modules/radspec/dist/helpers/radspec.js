"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _defineProperty2=_interopRequireDefault(require("@babel/runtime/helpers/defineProperty")),_ethers=require("ethers"),_methodRegistry=_interopRequireDefault(require("./lib/methodRegistry")),_lib=require("../lib/"),_data=require("../data/"),_defaults=require("../defaults");function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable})),keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var source,i=1;i<arguments.length;i++)source=null==arguments[i]?{}:arguments[i],i%2?ownKeys(Object(source),!0).forEach(function(key){(0,_defineProperty2.default)(target,key,source[key])}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))});return target}const makeUnknownFunctionNode=methodId=>({type:"string",value:`Unknown function (${methodId})`}),parse=signature=>{const fragment=_ethers.ethers.utils.FunctionFragment.from(signature);return{name:fragment.name.charAt(0).toUpperCase()+fragment.name.slice(1).split(/(?=[A-Z])/).join(" "),args:fragment.inputs.map(input=>({type:input.type}))}},getSigHah=sig=>_ethers.ethers.utils.hexDataSlice(_ethers.ethers.utils.id(sig),0,4),processFunctions=functions=>Object.keys(functions).reduce((acc,key)=>{const fragment=_ethers.ethers.utils.FunctionFragment.from(key);return _objectSpread({[getSigHah(fragment.format())]:{source:functions[key],fragment}},acc)},{});var _default=(provider,evaluator)=>/**
   * Interpret calldata using radspec recursively. If the function signature is not in the package's known
   * functions, it fallbacks to looking for the function name using github.com/parity-contracts/signature-registry
   *
   * @param {address} addr The target address of the call
   * @param {bytes} data The calldata of the call
   * @param {string} [registryAddress] The registry address to lookup descriptions
   * @return {Promise<radspec/evaluator/TypedValue>}
   */async(addr,data,registryAddress)=>{const functions=processFunctions(_data.knownFunctions);if(10>data.length)return makeUnknownFunctionNode(data);// Get method ID
const methodId=data.substr(0,10),fn=functions[methodId];// If function is not a known function
if(!fn)try{// Try checking on-chain signature registry
const registry=new _methodRegistry.default({registryAddress,provider,network:registryAddress?void 0:(await provider.getNetwork()).chainId}),result=await registry.lookup(methodId),{name}=parse(result);return{type:"string",value:name// TODO: should we decode and print the arguments as well?
}}catch{// Try fetching 4bytes API
const{results}=await _ethers.ethers.utils.fetchJson(`${_defaults.DEFAULT_API_4BYTES}?hex_signature=${methodId}`);if(Array.isArray(results)&&0<results.length){const{name}=parse(results[0].text_signature);return{type:"string",value:name}}// Fallback to unknown function
return makeUnknownFunctionNode(methodId)}// If the function was found in local radspec registry. Decode and evaluate.
const{source,fragment}=fn,ethersInterface=new _ethers.ethers.utils.Interface([fragment]),args=ethersInterface.decodeFunctionData(fragment.name,data),parameters=fragment.inputs.reduce((parameters,input,index)=>_objectSpread({[`$${index+1}`]:{type:input.type,value:args[index]}},parameters),{});return{type:"string",value:await(0,_lib.evaluateRaw)(source,parameters,{provider,availableHelpers:evaluator.helpers.getHelpers(),to:addr})}};exports.default=_default;
//# sourceMappingURL=radspec.js.map