{"version":3,"sources":["../../src/helpers/radspec.js"],"names":["makeUnknownFunctionNode","methodId","type","value","parse","signature","fragment","ethers","utils","FunctionFragment","from","name","charAt","toUpperCase","slice","split","join","args","inputs","map","input","getSigHah","sig","hexDataSlice","id","processFunctions","functions","Object","keys","reduce","acc","key","format","source","provider","evaluator","addr","data","registryAddress","knownFunctions","length","substr","fn","registry","MethodRegistry","network","getNetwork","chainId","result","lookup","results","fetchJson","DEFAULT_API_4BYTES","Array","isArray","text_signature","ethersInterface","Interface","decodeFunctionData","parameters","index","availableHelpers","helpers","getHelpers","to"],"mappings":"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","sourcesContent":["import { ethers } from 'ethers'\n\nimport MethodRegistry from './lib/methodRegistry'\nimport { evaluateRaw } from '../lib/'\nimport { knownFunctions } from '../data/'\nimport { DEFAULT_API_4BYTES } from '../defaults'\n\nconst makeUnknownFunctionNode = (methodId) => ({\n  type: 'string',\n  value: `Unknown function (${methodId})`\n})\n\nconst parse = (signature) => {\n  const fragment = ethers.utils.FunctionFragment.from(signature)\n\n  return {\n    name:\n      fragment.name.charAt(0).toUpperCase() +\n      fragment.name\n        .slice(1)\n        .split(/(?=[A-Z])/)\n        .join(' '),\n    args: fragment.inputs.map((input) => {\n      return { type: input.type }\n    })\n  }\n}\n\n// Hash signature with Ethereum Identity and silce bytes\nconst getSigHah = (sig) => ethers.utils.hexDataSlice(ethers.utils.id(sig), 0, 4)\n\n// Convert from the knownFunctions data format into the needed format\n// Input: { \"signature(type1,type2)\": \"Its radspec string\", ... }\n// Output: { \"0xabcdef12\": { \"fragment\": FunctionFragment, \"source\": \"Its radspec string\" }, ...}\nconst processFunctions = (functions) =>\n  Object.keys(functions).reduce((acc, key) => {\n    const fragment = ethers.utils.FunctionFragment.from(key)\n    return {\n      [getSigHah(fragment.format())]: { source: functions[key], fragment },\n      ...acc\n    }\n  }, {})\n\nexport default (provider, evaluator) =>\n  /**\n   * Interpret calldata using radspec recursively. If the function signature is not in the package's known\n   * functions, it fallbacks to looking for the function name using github.com/parity-contracts/signature-registry\n   *\n   * @param {address} addr The target address of the call\n   * @param {bytes} data The calldata of the call\n   * @param {string} [registryAddress] The registry address to lookup descriptions\n   * @return {Promise<radspec/evaluator/TypedValue>}\n   */\n  async (addr, data, registryAddress) => {\n    const functions = processFunctions(knownFunctions)\n\n    if (data.length < 10) {\n      return makeUnknownFunctionNode(data)\n    }\n\n    // Get method ID\n    const methodId = data.substr(0, 10)\n    const fn = functions[methodId]\n\n    // If function is not a known function\n    if (!fn) {\n      try {\n        // Try checking on-chain signature registry\n        const registry = new MethodRegistry({\n          registryAddress,\n          provider,\n          network: registryAddress\n            ? undefined\n            : (await provider.getNetwork()).chainId\n        })\n        const result = await registry.lookup(methodId)\n        const { name } = parse(result)\n        return {\n          type: 'string',\n          value: name // TODO: should we decode and print the arguments as well?\n        }\n      } catch {\n        // Try fetching 4bytes API\n        const { results } = await ethers.utils.fetchJson(\n          `${DEFAULT_API_4BYTES}?hex_signature=${methodId}`\n        )\n        if (Array.isArray(results) && results.length > 0) {\n          const { name } = parse(results[0].text_signature)\n          return {\n            type: 'string',\n            value: name\n          }\n        }\n        // Fallback to unknown function\n        return makeUnknownFunctionNode(methodId)\n      }\n    }\n    // If the function was found in local radspec registry. Decode and evaluate.\n    const { source, fragment } = fn\n\n    const ethersInterface = new ethers.utils.Interface([fragment])\n\n    // Decode parameters\n    const args = ethersInterface.decodeFunctionData(fragment.name, data)\n\n    const parameters = fragment.inputs.reduce(\n      (parameters, input, index) => ({\n        [`$${index + 1}`]: {\n          type: input.type,\n          value: args[index]\n        },\n        ...parameters\n      }),\n      {}\n    )\n\n    return {\n      type: 'string',\n      value: await evaluateRaw(source, parameters, {\n        provider,\n        availableHelpers: evaluator.helpers.getHelpers(),\n        to: addr\n      })\n    }\n  }\n"],"file":"radspec.js"}