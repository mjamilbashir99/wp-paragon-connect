{"version":3,"sources":["../../src/helpers/tokenAmount.js"],"names":["provider","tokenAddress","amount","showSymbol","precision","amountBn","BigNumber","from","fixed","decimals","symbol","ETH","token","ethers","Contract","ERC20_SYMBOL_DECIMALS_ABI","err","ERC20_SYMBOL_BYTES32_ABI","utils","toUtf8String","formattedAmount","type","value"],"mappings":"oMASgBA,QAAD,EACb;;;;;;;;KASA,MAAOC,YAAP,CAAqBC,MAArB,CAA6BC,UAAU,GAAvC,CAAgDC,SAAhD,GAA8D,MACtDC,CAAAA,QAAQ,CAAGC,kBAAUC,IAAV,CAAeL,MAAf,CAD2C,CAEtDM,KAAK,CAAG,CAAC,CAACJ,SAF4C,IAIxDK,CAAAA,QAJwD,CAKxDC,MALwD,CAO5D,GAAIT,YAAY,GAAKU,UAArB,CACEF,QAAQ,CAAGH,kBAAUC,IAAV,CAAe,EAAf,CADb,CAEMJ,UAFN,GAGIO,MAAM,CAAG,KAHb,MAKO,CACL,GAAIE,CAAAA,KAAK,CAAG,GAAIC,gBAAOC,QAAX,CACVb,YADU,CAEVc,gCAFU,CAGVf,QAHU,CAAZ,CAOA,GADAS,QAAQ,CAAGH,kBAAUC,IAAV,EAAe,KAAMK,CAAAA,KAAK,CAACH,QAAN,EAArB,EACX,CAAIN,UAAJ,CACE,GAAI,CACFO,MAAM,CAAG,CAAC,KAAME,CAAAA,KAAK,CAACF,MAAN,EAAP,GAA0B,EACpC,CAAC,MAAOM,GAAP,CAAY,CAEZJ,KAAK,CAAG,GAAIC,gBAAOC,QAAX,CACNb,YADM,CAENgB,+BAFM,CAGNjB,QAHM,CAFI,CAOZU,MAAM,CAAG,CAAC,KAAME,CAAAA,KAAK,CAACF,MAAN,EAAP,GAA0B,EAPvB,CAQZA,MAAM,CAAGA,MAAM,EAAIG,eAAOK,KAAP,CAAaC,YAAb,CAA0BT,MAA1B,CACpB,CAEJ,CAEDN,SAAS,CAAGA,SAAS,EAAIK,QApCmC,CAsC5D,KAAMW,CAAAA,eAAe,CAAG,uBACtBf,QADsB,CAEtB,qBAAOI,QAAP,CAFsB,EAGfL,SAHe,CAItBI,KAJsB,CAAxB,CAOA,MAAO,CACLa,IAAI,CAAE,QADD,CAELC,KAAK,CAAEnB,UAAU,CAAI,GAAEiB,eAAgB,IAAGV,MAAO,EAAhC,CAAoCU,eAFhD,CAIR,C","sourcesContent":["import { ethers, BigNumber } from 'ethers'\n\nimport {\n  ERC20_SYMBOL_BYTES32_ABI,\n  ERC20_SYMBOL_DECIMALS_ABI,\n  ETH\n} from './lib/token'\nimport { formatBN, tenPow } from './lib/formatBN'\n\nexport default (provider) =>\n  /**\n   * Format token amounts taking decimals into account\n   *\n   * @param {string} tokenAddress The address of the token\n   * @param {*} amount The absolute amount for the token quantity (wei)\n   * @param {bool} showSymbol Whether the token symbol will be printed after the amount\n   * @param {*} precision The number of decimal places to format to. If set, the precision is always enforced.\n   * @return {Promise<radspec/evaluator/TypedValue>}\n   */\n  async (tokenAddress, amount, showSymbol = true, precision) => {\n    const amountBn = BigNumber.from(amount)\n    const fixed = !!precision\n\n    let decimals\n    let symbol\n\n    if (tokenAddress === ETH) {\n      decimals = BigNumber.from(18)\n      if (showSymbol) {\n        symbol = 'ETH'\n      }\n    } else {\n      let token = new ethers.Contract(\n        tokenAddress,\n        ERC20_SYMBOL_DECIMALS_ABI,\n        provider\n      )\n\n      decimals = BigNumber.from(await token.decimals())\n      if (showSymbol) {\n        try {\n          symbol = (await token.symbol()) || ''\n        } catch (err) {\n          // Some tokens (e.g. DS-Token) use bytes32 for their symbol()\n          token = new ethers.Contract(\n            tokenAddress,\n            ERC20_SYMBOL_BYTES32_ABI,\n            provider\n          )\n          symbol = (await token.symbol()) || ''\n          symbol = symbol && ethers.utils.toUtf8String(symbol)\n        }\n      }\n    }\n\n    precision = precision || decimals\n\n    const formattedAmount = formatBN(\n      amountBn,\n      tenPow(decimals),\n      Number(precision),\n      fixed\n    )\n\n    return {\n      type: 'string',\n      value: showSymbol ? `${formattedAmount} ${symbol}` : formattedAmount\n    }\n  }\n"],"file":"tokenAmount.js"}