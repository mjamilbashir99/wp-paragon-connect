"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findAppMethodFromIntent = exports.validateMethod = exports.isFullMethodSignature = exports.apmAppId = void 0;
const ethers_1 = require("ethers");
exports.apmAppId = (appName) => ethers_1.ethers.utils.namehash(`${appName}.aragonpm.eth`);
// Is the given method a full signature, e.g. 'foo(arg1,arg2,...)'
exports.isFullMethodSignature = (methodSignature) => {
    return (Boolean(methodSignature) &&
        methodSignature.includes('(') &&
        methodSignature.includes(')'));
};
function validateMethod(destination, methodSignature, destinationApp) {
    const methods = destinationApp.intents;
    if (!methods) {
        throw new Error(`No functions specified in artifact for ${destination}`);
    }
    // Find the relevant method information
    const method = methods.find(method => exports.isFullMethodSignature(methodSignature)
        ? method.sig === methodSignature
        : // If the full signature isn't given, just select the first overload declared
            method.sig.split('(')[0] === methodSignature);
    if (!method) {
        throw new Error(`No method named ${methodSignature} on ${destination}`);
    }
    return method;
}
exports.validateMethod = validateMethod;
/**
 * Find the method descriptor corresponding to the data component of a
 * transaction sent to `app`.
 *
 * @param  {Object} app App artifact
 * @param  {Object} data Data component of a transaction to app
 * @return {Object|void} Method with radspec notice and function signature, or undefined if none was found
 */
function findAppMethodFromIntent(app, transaction) {
    const methodId = transaction.data.substring(0, 10);
    const checkMethodSignature = (siganture) => {
        // Hash signature with Ethereum Identity and silce bytes
        const sigHash = ethers_1.ethers.utils.hexDataSlice(ethers_1.ethers.utils.id(siganture), 0, 4);
        return sigHash === methodId;
    };
    const { deprecatedIntents, intents } = app || {};
    let method;
    // First try to find the method in the current functions
    if (Array.isArray(intents)) {
        method = intents.find(method => checkMethodSignature(method.sig));
    }
    if (!method) {
        // The current functions didn't have it; try with each deprecated version's functions
        const deprecatedFunctionsFromVersions = Object.values(deprecatedIntents || {});
        if (deprecatedFunctionsFromVersions.every(Array.isArray)) {
            // Flatten all the deprecated functions
            const allDeprecatedFunctions = [].concat(...deprecatedFunctionsFromVersions);
            method = allDeprecatedFunctions.find(method => checkMethodSignature(method.sig));
        }
    }
    return method;
}
exports.findAppMethodFromIntent = findAppMethodFromIntent;
//# sourceMappingURL=app.js.map