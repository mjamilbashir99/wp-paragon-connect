"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.postprocessRadspecDescription = void 0;
const address_1 = require("../address");
const kernel_1 = require("../kernel");
/**
 * Look for known addresses and roles in a radspec description and substitute them with a human string
 *
 * @param  {string} description
 * @return {Promise<Object>} Description and annotated description
 */
async function postprocessRadspecDescription(description, apps) {
    const addressRegexStr = '0x[a-fA-F0-9]{40}';
    const addressRegex = new RegExp(`^${addressRegexStr}$`);
    const bytes32RegexStr = '0x[a-f0-9]{64}';
    const bytes32Regex = new RegExp(`^${bytes32RegexStr}$`);
    const combinedRegex = new RegExp(`\\b(${addressRegexStr}|${bytes32RegexStr})\\b`);
    const tokens = description
        .split(combinedRegex)
        .map(token => token.trim())
        .filter(token => token);
    if (tokens.length < 1) {
        return { description };
    }
    const roles = [];
    for (const app of apps) {
        const appRoles = await app.roles();
        roles.concat(appRoles);
    }
    const annotateAddress = (input) => {
        if (address_1.addressesEqual(input, address_1.ANY_ENTITY)) {
            return [
                input,
                '"Any account"',
                { type: 'any-account', value: address_1.ANY_ENTITY },
            ];
        }
        const app = apps.find(({ address }) => address_1.addressesEqual(address, input));
        if (app) {
            const replacement = `${app.name}${app.appId ? ` (${app.appId})` : ''}`;
            return [input, `“${replacement}”`, { type: 'app', value: app }];
        }
        return [input, input, { type: 'address', value: input }];
    };
    const annotateBytes32 = (input) => {
        const role = roles.find(({ hash }) => hash === input);
        if (role && role.name) {
            return [input, `“${role.name}”`, { type: 'role', value: role }];
        }
        const app = apps.find(({ appId }) => appId === input);
        if (app) {
            // return the entire app as it contains APM package details
            return [input, `“${app.appName}”`, { type: 'apmPackage', value: app }];
        }
        const namespace = kernel_1.getKernelNamespace(input);
        if (namespace) {
            return [
                input,
                `“${namespace.name}”`,
                { type: 'kernelNamespace', value: namespace },
            ];
        }
        return [input, input, { type: 'bytes32', value: input }];
    };
    const annotateText = (input) => {
        return [input, input, { type: 'text', value: input }];
    };
    const annotatedTokens = tokens.map(token => {
        if (addressRegex.test(token)) {
            return annotateAddress(token);
        }
        if (bytes32Regex.test(token)) {
            return annotateBytes32(token);
        }
        return annotateText(token);
    });
    const compiled = annotatedTokens.reduce(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    (acc, [_, replacement, annotation]) => {
        acc.description.push(replacement);
        acc.annotatedDescription.push(annotation);
        return acc;
    }, {
        annotatedDescription: [],
        description: [],
    });
    return {
        annotatedDescription: compiled.annotatedDescription,
        description: compiled.description.join(' '),
    };
}
exports.postprocessRadspecDescription = postprocessRadspecDescription;
//# sourceMappingURL=postprocess.js.map