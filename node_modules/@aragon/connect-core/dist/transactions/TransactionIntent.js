"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _org, _provider;
Object.defineProperty(exports, "__esModule", { value: true });
const TransactionPath_1 = __importDefault(require("./TransactionPath"));
const calculatePath_1 = require("../utils/path/calculatePath");
const descriptions_1 = require("../utils/descriptions");
class TransactionIntent {
    constructor(data, org, provider) {
        _org.set(this, void 0);
        _provider.set(this, void 0);
        __classPrivateFieldSet(this, _org, org);
        __classPrivateFieldSet(this, _provider, provider);
        this.contractAddress = data.contractAddress;
        this.functionArgs = data.functionArgs;
        this.functionName = data.functionName;
    }
    async paths(account, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    options) {
        const apps = await __classPrivateFieldGet(this, _org).apps();
        const { forwardingFeePretransaction, path, } = await calculatePath_1.calculateTransactionPath(account, this.contractAddress, this.functionName, this.functionArgs, apps, __classPrivateFieldGet(this, _provider));
        const describedPath = await descriptions_1.describeTransactionPath(path, apps, __classPrivateFieldGet(this, _provider));
        return new TransactionPath_1.default({
            apps: apps.filter(app => path
                .map(transaction => transaction.to)
                .some(address => address === app.address)),
            destination: apps.find(app => app.address == this.contractAddress),
            forwardingFeePretransaction,
            transactions: describedPath,
        });
    }
    async transactions(account, options) {
        return (await this.paths(account, options)).transactions;
    }
}
exports.default = TransactionIntent;
_org = new WeakMap(), _provider = new WeakMap();
//# sourceMappingURL=TransactionIntent.js.map