"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _client, _verbose;
Object.defineProperty(exports, "__esModule", { value: true });
const isomorphic_unfetch_1 = __importDefault(require("isomorphic-unfetch"));
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
const core_1 = require("@urql/core");
const subscriptions_transport_ws_1 = require("subscriptions-transport-ws");
const wonka_1 = require("wonka");
class GraphQLWrapper {
    constructor(subgraphUrl, verbose = false) {
        _client.set(this, void 0);
        _verbose.set(this, void 0);
        if (!subgraphUrl || !subgraphUrl.startsWith('http')) {
            throw new Error('Please provide a valid subgraph URL');
        }
        const subscriptionClient = new subscriptions_transport_ws_1.SubscriptionClient(subgraphUrl.replace('http', 'ws'), {
            reconnect: true,
            timeout: 20000,
        }, isomorphic_ws_1.default);
        __classPrivateFieldSet(this, _client, new core_1.Client({
            maskTypename: true,
            url: subgraphUrl,
            fetch: isomorphic_unfetch_1.default,
            exchanges: [
                ...core_1.defaultExchanges,
                core_1.subscriptionExchange({
                    forwardSubscription: (operation) => subscriptionClient.request(operation),
                }),
            ],
        }));
        __classPrivateFieldSet(this, _verbose, verbose);
    }
    subscribeToQuery(query, args = {}, callback) {
        const request = core_1.createRequest(query, args);
        return wonka_1.pipe(__classPrivateFieldGet(this, _client).executeSubscription(request), wonka_1.subscribe((result) => {
            if (__classPrivateFieldGet(this, _verbose)) {
                console.log(this.describeQueryResult(result));
            }
            if (result.error) {
                throw new Error([
                    'Error performing subscription.',
                    `${result.error.name}: ${result.error.message}`,
                    this.describeQueryResult(result),
                ].join('\n'));
            }
            callback(result);
        }));
    }
    subscribeToQueryWithParser(query, args = {}, callback, parser) {
        return this.subscribeToQuery(query, args, async (result) => {
            callback(await this.parseQueryResult(parser, result));
        });
    }
    async performQuery(query, args = {}) {
        const result = await __classPrivateFieldGet(this, _client).query(query, args).toPromise();
        if (__classPrivateFieldGet(this, _verbose)) {
            console.log(this.describeQueryResult(result));
        }
        if (result.error) {
            throw new Error(this.describeQueryResultError(result) + this.describeQueryResult(result));
        }
        return result;
    }
    async performQueryWithParser(query, args = {}, parser) {
        const result = await this.performQuery(query, args);
        return this.parseQueryResult(parser, result);
    }
    async parseQueryResult(parser, result) {
        try {
            return parser(result, this);
        }
        catch (error) {
            throw new Error(error.message + '\n\n' + this.describeQueryResult(result));
        }
    }
    describeQueryResultError(result) {
        if (!result.error) {
            return '';
        }
        return `${result.error.name}: ${result.error.message}\n\n`;
    }
    describeQueryResult(result) {
        var _a;
        const queryStr = (_a = result.operation.query.loc) === null || _a === void 0 ? void 0 : _a.source.body;
        const dataStr = JSON.stringify(result.data, null, 2);
        const argsStr = JSON.stringify(result.operation.variables, null, 2);
        const subgraphUrl = result.operation.context.url;
        return [
            `Subgraph: ${subgraphUrl}`,
            `Arguments: ${argsStr}`,
            `Query: ${queryStr}`,
            `Returned data: ${dataStr}`,
        ].join('\n\n');
    }
}
exports.default = GraphQLWrapper;
_client = new WeakMap(), _verbose = new WeakMap();
//# sourceMappingURL=GraphQLWrapper.js.map