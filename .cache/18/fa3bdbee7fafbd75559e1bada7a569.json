{"id":"node_modules/radspec/dist/helpers/radspec.js","dependencies":[{"name":"C:\\xampp\\htdocs\\aragon-connect\\node_modules\\radspec\\dist\\helpers\\radspec.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\xampp\\htdocs\\aragon-connect\\package.json","includedInParent":true,"mtime":1595855422975},{"name":"C:\\xampp\\htdocs\\aragon-connect\\node_modules\\radspec\\package.json","includedInParent":true,"mtime":1595838173348},{"name":"@babel/runtime/helpers/interopRequireDefault","loc":{"line":1,"column":48},"parent":"C:\\xampp\\htdocs\\aragon-connect\\node_modules\\radspec\\dist\\helpers\\radspec.js","resolved":"C:\\xampp\\htdocs\\aragon-connect\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js"},{"name":"@babel/runtime/helpers/defineProperty","loc":{"line":1,"column":226},"parent":"C:\\xampp\\htdocs\\aragon-connect\\node_modules\\radspec\\dist\\helpers\\radspec.js","resolved":"C:\\xampp\\htdocs\\aragon-connect\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js"},{"name":"ethers","loc":{"line":1,"column":284},"parent":"C:\\xampp\\htdocs\\aragon-connect\\node_modules\\radspec\\dist\\helpers\\radspec.js","resolved":"C:\\xampp\\htdocs\\aragon-connect\\node_modules\\ethers\\dist\\ethers.umd.js"},{"name":"./lib/methodRegistry","loc":{"line":1,"column":341},"parent":"C:\\xampp\\htdocs\\aragon-connect\\node_modules\\radspec\\dist\\helpers\\radspec.js","resolved":"C:\\xampp\\htdocs\\aragon-connect\\node_modules\\radspec\\dist\\helpers\\lib\\methodRegistry.js"},{"name":"../lib/","loc":{"line":1,"column":379},"parent":"C:\\xampp\\htdocs\\aragon-connect\\node_modules\\radspec\\dist\\helpers\\radspec.js","resolved":"C:\\xampp\\htdocs\\aragon-connect\\node_modules\\radspec\\dist\\lib\\index.js"},{"name":"../data/","loc":{"line":1,"column":404},"parent":"C:\\xampp\\htdocs\\aragon-connect\\node_modules\\radspec\\dist\\helpers\\radspec.js","resolved":"C:\\xampp\\htdocs\\aragon-connect\\node_modules\\radspec\\dist\\data\\index.js"},{"name":"../defaults","loc":{"line":1,"column":434},"parent":"C:\\xampp\\htdocs\\aragon-connect\\node_modules\\radspec\\dist\\helpers\\radspec.js","resolved":"C:\\xampp\\htdocs\\aragon-connect\\node_modules\\radspec\\dist\\defaults.js"}],"generated":{"js":"\"use strict\";var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.default=void 0;var _defineProperty2=_interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\")),_ethers=require(\"ethers\"),_methodRegistry=_interopRequireDefault(require(\"./lib/methodRegistry\")),_lib=require(\"../lib/\"),_data=require(\"../data/\"),_defaults=require(\"../defaults\");function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable})),keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var source,i=1;i<arguments.length;i++)source=null==arguments[i]?{}:arguments[i],i%2?ownKeys(Object(source),!0).forEach(function(key){(0,_defineProperty2.default)(target,key,source[key])}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))});return target}const makeUnknownFunctionNode=methodId=>({type:\"string\",value:`Unknown function (${methodId})`}),parse=signature=>{const fragment=_ethers.ethers.utils.FunctionFragment.from(signature);return{name:fragment.name.charAt(0).toUpperCase()+fragment.name.slice(1).split(/(?=[A-Z])/).join(\" \"),args:fragment.inputs.map(input=>({type:input.type}))}},getSigHah=sig=>_ethers.ethers.utils.hexDataSlice(_ethers.ethers.utils.id(sig),0,4),processFunctions=functions=>Object.keys(functions).reduce((acc,key)=>{const fragment=_ethers.ethers.utils.FunctionFragment.from(key);return _objectSpread({[getSigHah(fragment.format())]:{source:functions[key],fragment}},acc)},{});var _default=(provider,evaluator)=>/**\n   * Interpret calldata using radspec recursively. If the function signature is not in the package's known\n   * functions, it fallbacks to looking for the function name using github.com/parity-contracts/signature-registry\n   *\n   * @param {address} addr The target address of the call\n   * @param {bytes} data The calldata of the call\n   * @param {string} [registryAddress] The registry address to lookup descriptions\n   * @return {Promise<radspec/evaluator/TypedValue>}\n   */async(addr,data,registryAddress)=>{const functions=processFunctions(_data.knownFunctions);if(10>data.length)return makeUnknownFunctionNode(data);// Get method ID\nconst methodId=data.substr(0,10),fn=functions[methodId];// If function is not a known function\nif(!fn)try{// Try checking on-chain signature registry\nconst registry=new _methodRegistry.default({registryAddress,provider,network:registryAddress?void 0:(await provider.getNetwork()).chainId}),result=await registry.lookup(methodId),{name}=parse(result);return{type:\"string\",value:name// TODO: should we decode and print the arguments as well?\n}}catch{// Try fetching 4bytes API\nconst{results}=await _ethers.ethers.utils.fetchJson(`${_defaults.DEFAULT_API_4BYTES}?hex_signature=${methodId}`);if(Array.isArray(results)&&0<results.length){const{name}=parse(results[0].text_signature);return{type:\"string\",value:name}}// Fallback to unknown function\nreturn makeUnknownFunctionNode(methodId)}// If the function was found in local radspec registry. Decode and evaluate.\nconst{source,fragment}=fn,ethersInterface=new _ethers.ethers.utils.Interface([fragment]),args=ethersInterface.decodeFunctionData(fragment.name,data),parameters=fragment.inputs.reduce((parameters,input,index)=>_objectSpread({[`$${index+1}`]:{type:input.type,value:args[index]}},parameters),{});return{type:\"string\",value:await(0,_lib.evaluateRaw)(source,parameters,{provider,availableHelpers:evaluator.helpers.getHelpers(),to:addr})}};exports.default=_default;\n"},"sourceMaps":{"js":{"version":3,"sources":["../../src/helpers/radspec.js"],"names":["makeUnknownFunctionNode","methodId","type","value","parse","signature","fragment","ethers","utils","FunctionFragment","from","name","charAt","toUpperCase","slice","split","join","args","inputs","map","input","getSigHah","sig","hexDataSlice","id","processFunctions","functions","Object","keys","reduce","acc","key","format","source","provider","evaluator","addr","data","registryAddress","knownFunctions","length","substr","fn","registry","MethodRegistry","network","getNetwork","chainId","result","lookup","results","fetchJson","DEFAULT_API_4BYTES","Array","isArray","text_signature","ethersInterface","Interface","decodeFunctionData","parameters","index","availableHelpers","helpers","getHelpers","to"],"mappings":"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","sourcesContent":["import { ethers } from 'ethers'\n\nimport MethodRegistry from './lib/methodRegistry'\nimport { evaluateRaw } from '../lib/'\nimport { knownFunctions } from '../data/'\nimport { DEFAULT_API_4BYTES } from '../defaults'\n\nconst makeUnknownFunctionNode = (methodId) => ({\n  type: 'string',\n  value: `Unknown function (${methodId})`\n})\n\nconst parse = (signature) => {\n  const fragment = ethers.utils.FunctionFragment.from(signature)\n\n  return {\n    name:\n      fragment.name.charAt(0).toUpperCase() +\n      fragment.name\n        .slice(1)\n        .split(/(?=[A-Z])/)\n        .join(' '),\n    args: fragment.inputs.map((input) => {\n      return { type: input.type }\n    })\n  }\n}\n\n// Hash signature with Ethereum Identity and silce bytes\nconst getSigHah = (sig) => ethers.utils.hexDataSlice(ethers.utils.id(sig), 0, 4)\n\n// Convert from the knownFunctions data format into the needed format\n// Input: { \"signature(type1,type2)\": \"Its radspec string\", ... }\n// Output: { \"0xabcdef12\": { \"fragment\": FunctionFragment, \"source\": \"Its radspec string\" }, ...}\nconst processFunctions = (functions) =>\n  Object.keys(functions).reduce((acc, key) => {\n    const fragment = ethers.utils.FunctionFragment.from(key)\n    return {\n      [getSigHah(fragment.format())]: { source: functions[key], fragment },\n      ...acc\n    }\n  }, {})\n\nexport default (provider, evaluator) =>\n  /**\n   * Interpret calldata using radspec recursively. If the function signature is not in the package's known\n   * functions, it fallbacks to looking for the function name using github.com/parity-contracts/signature-registry\n   *\n   * @param {address} addr The target address of the call\n   * @param {bytes} data The calldata of the call\n   * @param {string} [registryAddress] The registry address to lookup descriptions\n   * @return {Promise<radspec/evaluator/TypedValue>}\n   */\n  async (addr, data, registryAddress) => {\n    const functions = processFunctions(knownFunctions)\n\n    if (data.length < 10) {\n      return makeUnknownFunctionNode(data)\n    }\n\n    // Get method ID\n    const methodId = data.substr(0, 10)\n    const fn = functions[methodId]\n\n    // If function is not a known function\n    if (!fn) {\n      try {\n        // Try checking on-chain signature registry\n        const registry = new MethodRegistry({\n          registryAddress,\n          provider,\n          network: registryAddress\n            ? undefined\n            : (await provider.getNetwork()).chainId\n        })\n        const result = await registry.lookup(methodId)\n        const { name } = parse(result)\n        return {\n          type: 'string',\n          value: name // TODO: should we decode and print the arguments as well?\n        }\n      } catch {\n        // Try fetching 4bytes API\n        const { results } = await ethers.utils.fetchJson(\n          `${DEFAULT_API_4BYTES}?hex_signature=${methodId}`\n        )\n        if (Array.isArray(results) && results.length > 0) {\n          const { name } = parse(results[0].text_signature)\n          return {\n            type: 'string',\n            value: name\n          }\n        }\n        // Fallback to unknown function\n        return makeUnknownFunctionNode(methodId)\n      }\n    }\n    // If the function was found in local radspec registry. Decode and evaluate.\n    const { source, fragment } = fn\n\n    const ethersInterface = new ethers.utils.Interface([fragment])\n\n    // Decode parameters\n    const args = ethersInterface.decodeFunctionData(fragment.name, data)\n\n    const parameters = fragment.inputs.reduce(\n      (parameters, input, index) => ({\n        [`$${index + 1}`]: {\n          type: input.type,\n          value: args[index]\n        },\n        ...parameters\n      }),\n      {}\n    )\n\n    return {\n      type: 'string',\n      value: await evaluateRaw(source, parameters, {\n        provider,\n        availableHelpers: evaluator.helpers.getHelpers(),\n        to: addr\n      })\n    }\n  }\n"],"file":"radspec.js"}},"error":null,"hash":"cff90ab49c09fadb5cca91d8f5755286","cacheData":{"env":{}}}